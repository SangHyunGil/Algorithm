"""
펠린드롬은 투포인터로 잘 알려진 문제 중 하나이다.
하지만, 이번에는 시간복잡도 측면에서 투포인터를 사용하면 안된다.
투 포인터의 경우 펠린드롬을 구하는 것 자체는 O(N)만큼의 비용이 든다.
그래서 O(2000)만큼의 비용으로만 해결할 수 있는거 아닌가? 라는 판단으로 접근하면 큰일이다.
문제의 조건을 살펴보면 홍준이가 한 "질문의 개수"라는 어구를 볼 수 있을 것이다.
이는 최대 1000000이라고 한다.
그렇다면 한 투 포인터로 구하는 비용은 O(N*M) => O(2000 * 1000000) => 약 20억의 연산이 필요하다.
0.5초만에 통과할리 만무하다.
그렇다면 다른 접근을 생각해보자. 
바로 DP이다.
DP를 통해 펠린드롬을 미리 다 구해놓고 진행하면 어떨까?
펠린드롬을 보면 결국 이전 펠린드롬의 연속이라고 봐도 무방하다.
1 2 3 2 1 은
2 3 2 에서 단순 양 끝에 1 1을 붙인 것이 아닌가.
바로 이 부분에서 DP의 개념을 사용할 수 있다.
(2, 4)에서 펠린드롬이고 양 끝이 같다면 그 부분 문자열은 바로 펠린드롬이다.
이 부분을 점화식으로 세우면 다음과 같다.
i를 왼쪽 끝, j를 오른쪽 끝의 인덱스라 하자.
DP[i][j] = 1 if S[i] == S[j] and DP[i+1][j-1] else 0
S[i] == S[j] => 두 문자열이 같은가
DP[i+1][j-1] => (i+1, j-1)이 펠린드롬인가
"""

import sys
input = sys.stdin.readline

N = int(input())
S = [*map(int, input().split())]
DP = [[1 if i == j else 0 for j in range(N)] for i in range(N)]

for i in range(N-1):
    if S[i] == S[i+1]:
        DP[i][i+1] = 1

for i in range(2, N):
    for j in range(i-1):
        if S[i] == S[j] and DP[j+1][i-1]:
            DP[j][i] = 1

for _ in range(int(input())):
    A, B = map(int, input().split())
    print(DP[A-1][B-1])
